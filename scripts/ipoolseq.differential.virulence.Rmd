---
output:
  pdf_document: default
  html_document: default
# ipoolseq.differential.virulence.Rmd, Copyright 2016, 2017, 2018, 2019 Florian G. Pflug
# 
# This file is part of the iPool-Seq Analysis Pipeline
#
# The iPool-Seq Analysis Pipeline is free software: you can redistribute it
# and/or modify it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the License,
# or (at your option) any later version.
#
# The iPool-Seq Analysis Pipeline is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with the iPool-Seq Analysis Pipeline.  If not, see
# <http://www.gnu.org/licenses/
---

```{r stub, include=FALSE, eval=FALSE}
# Set "eval=TRUE" above to run this chunk interactively in R Studio,
# and adjust the input and output files to point to the sample you
# want to test with
design <- "Uhse_et_al.2018"
replicate <- "expA.r1"
setClass("SnakemakeStub", representation(input = "list", output = "list"))
snakemake <- new("SnakemakeStub",
                 input=list(gff=paste("..", "cfg", design, "knockouts.gff", sep="/"),
                            pool_in=paste("..", "tests", "data", design, paste0(replicate, "-in.count.tab"), sep="/"),
                            pool_out=paste("..", "tests", "data", design, paste0(replicate, "-out.count.tab"), sep="/"),
                            stats_in=paste("..", "tests", "data", design, paste0(replicate, "-in.stats.tab"), sep="/"),
                            stats_out=paste("..", "tests", "data", design, paste0(replicate, "-out.stats.tab"), sep="/"),
                            trumicount_pdf_in=paste("..", "tests", "data", design, paste0(replicate, "-in.count.pdf"), sep="/"),
                            trumicount_pdf_out=paste("..", "tests", "data", design, paste0(replicate, "-out.count.pdf"), sep="/"),
                            fastqc_html_in_r1=paste("..", "tests", "data", design, paste0(replicate, "-in.fastqc.1.html"), sep="/"),
                            fastqc_html_in_r2=paste("..", "tests", "data", design, paste0(replicate, "-in.fastqc.2.html"), sep="/"),
                            fastqc_html_out_r1=paste("..", "tests", "data", design, paste0(replicate, "-out.fastqc.1.html"), sep="/"),
                            fastqc_html_out_r2=paste("..", "tests", "data", design, paste0(replicate, "-out.fastqc.2.html"), sep="/")),
                 params=list(version={f <- file("../VERSION", "r"); v <- readLines(f, n=1); close(f); v},
                             dir=design, exp=replicate),
                 output=list(table=paste("..", "tests", "data", design, paste0(replicate, "dv.tab"), sep="/")))
```

---
title: "Differential Virulence Report for `r snakemake@params$exp` (`r snakemake@params$dir`)"
author: "iPoolSeq-Pipeline `r snakemake@params$version`"
date: "`r format(Sys.time(), "%d %B, %Y")`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	message = FALSE,
	warning = FALSE,
	echo = FALSE,
	cache = FALSE
)

library(data.table)
library(DT)
library(rtracklayer)
library(plotly)

source("scripts/ipoolseq.model.R")

# Output '-' for NA values
options(knitr.kable.NA = '-')

# Set FDR to 5%
PLOT.FDR.THRESHOLD <- 0.05

# Convert a p-value into a significance marker
#   '?'     if p notin [0, 1]
#   ' '     if p in (1e-1, 1]
#   '+'     if p in (5e-2, 1e-1]
#   '*'     if p in (1e-2, 5e-1]
#   '**'    if p in (1e-3, 1e-2]
#   '***'   if p in (1e-4, 1e-3]
#   '****'  if p in (1e-5, 1e-4]
#   '*****' if p in [0,    1e-5]
sig.stars <- function(p) {
  pp <- ifelse((p > 0) & (p < 1), p, 0.5)
  ifelse(!is.finite(p) | (p < 0) | (p > 1), "?",
         ifelse(p > 0.1, " ",
                ifelse(p > 0.05, "+",
                       ifelse(p == 0, "*****",
                              strrep("*", pmin(ceiling(-log10(pp)*(1+.Machine$double.eps))-1, 5))))))
}

# Create a Markdown link
make_link <- function(path) {
  paste0('[', path, '](', path, ')')
}
```

```{r load}
# Load list of knockouts, find assumed neutral set
message("Loading knockouts from ", snakemake@input$gff)
knockouts <- readGFF(snakemake@input$gff, version=2)
NEUTRAL <- knockouts$Name[knockouts$Neutral == 1]

# Load UMI count tables produced by TRUmiCount
load.trumicount.output <- function(file) {
  message("Loading TRUmiCount results from ", file)
  t <- data.table(read.table(file, header=TRUE, sep='\t'))
  # Make sure there are exactly two rows per knockout
  allgenes <- data.table(gene=c(paste0(knockouts$Name, ':5p'),
                                paste0(knockouts$Name, ':3p')))
  t <- t[allgenes,, on="gene"]
  # The raw "gene" column contains <gene>:<flank>, split into two separate fields
  t[, flank := sapply(strsplit(as.character(gene), split=":", fixed=TRUE), FUN=function(f) { f[2] }) ]
  t[, knockout := sapply(strsplit(as.character(gene), split=":", fixed=TRUE), FUN=function(f) { f[1] }) ]
}
counts.flank.in <- load.trumicount.output(snakemake@input[["pool_in"]])
counts.flank.out <- load.trumicount.output(snakemake@input[["pool_out"]])

# Aggregate the data for the 5' and 3' flank of each gene.
# We add the counts and average the losses of the two flanks for each gene,
combine.flanks <- function(counts.flank) {
  counts.flank[, list(
    n = sum(n.obs, na.rm=TRUE),
    loss = mean(loss, na.rm=TRUE)
  ), by="knockout"]
}
counts.in <- combine.flanks(counts.flank.in)
counts.out <- combine.flanks(counts.flank.out)

# Combine input and output pool data into a single table
counts <- merge(counts.in, counts.out, by="knockout", suffixes=c(".in", ".out"))[,list(
  knockout,
  is.neutral=knockout %in% NEUTRAL,
  n.in, loss.in,
  n.out, loss.out,
  abundance.in=n.in / (2 * (1-loss.in)),
  abundance.out=n.out / (2 * (1-loss.out))
)]
```

# 1. Files

```{r table_files}
knitr::kable(data.frame(row.names=c("knockouts",
                                    "input pool (pre-infection) knockout abundances ",
                                    "output pool (post-infection) knockout abundances",
                                    "log2 fold changes & significance"),
                        file=c(snakemake@input$gff,
                               make_link(basename(snakemake@input$pool_in)),
                               make_link(basename(snakemake@input$pool_out)),
                               make_link(basename(snakemake@output$table))),
                        report=c("",
                                 paste0("[TRUmiCount report](", basename(snakemake@input$trumicount_pdf_in), ")"),
                                 paste0("[TRUmiCount report](", basename(snakemake@input$trumicount_pdf_out), ")"),
                                 "")))
```

# 2. Quality Control

## Sequencing and Trimming

FastQC reports for the trimmed reads
```{r table_fastqc}
knitr::kable(data.frame(
  row.names=c("Read 1", "Read 2"),
  `Input pool`=c(paste0("[FastQC report](", basename(snakemake@input$fastqc_html_in_r1), ")"),
                 paste0("[FastQC report](", basename(snakemake@input$fastqc_html_in_r2), ")")),
  `Output pool`=c(paste0("[FastQC report](", basename(snakemake@input$fastqc_html_out_r1), ")"),
                  paste0("[FastQC report](", basename(snakemake@input$fastqc_html_out_r2), ")")),
  check.names=FALSE
))
```

## Read and UMI count statistics

The number of read pairs after each of the analysis steps
```{r table_stats_in}
message("Loading statistics from ", snakemake@input$stats_in)
stats_in <- read.table(snakemake@input$stats_in, header=TRUE, sep="\t", comment.char='', na.strings='-', check.names=FALSE)
message("Loading statistics from ", snakemake@input$stats_out)
stats_out <- read.table(snakemake@input$stats_out, header=TRUE, sep="\t", comment.char='', na.strings='-', check.names=FALSE)

stopifnot(all(stats_in$`After Step` == stats_out$`After Step`))
stats <- data.frame(row.names=stats_in$`After Step`,
                    `#Reads Input`=stats_in$`#Reads`,
                    `#UMIs Input`=stats_in$`#UMIs`,
                    `#Reads Output`=stats_out$`#Reads`,
                    `#UMIs Output`=stats_out$`#UMIs`,
                    check.names=FALSE)
for(c in c('#Reads Input', '#UMIs Input', '#Reads Output', '#UMIs Output')) {
  stats[[c]] <- ifelse(!is.na(stats[[c]]),
                       paste0(stats[[c]], " (",
                              round(100*stats[[c]]/(stats[[c]][min(which(!is.na(stats[[c]])))])), "%)"),
                       NA)
}
knitr::kable(stats)
```

For the distribution of the number of reads per UMI, see the *TRUmiCount reports* linked in the list of files above.

## Correlation of 3' and 5' Flank

```{r table_corr_flanks}
group.by.knockout <- function(data) {
  data[, list(n5p=n.obs[flank=="5p"],
              l5p=loss[flank=="5p"],
              n3p=n.obs[flank=="3p"],
              l3p=loss[flank=="3p"])
       , by="knockout"]
}

knitr::kable(data.table(
  `Pool`=c(
  "input",
  "output",
  "input",
  "output"
  ),
  Type=c(
  "Raw",
  "Raw",
  "Loss-corr.",
  "Loss-corr."
  ),
  `Correlation 5' vs. 3'`=c(
  group.by.knockout(counts.flank.in)[, cor(n5p, n3p, use='complete.obs')],
  group.by.knockout(counts.flank.out)[, cor(n5p, n3p, use='complete.obs')],
  group.by.knockout(counts.flank.in)[, cor(n5p/(1-l5p), n3p/(1-l3p), use='complete.obs')],
  group.by.knockout(counts.flank.out)[, cor(n5p/(1-l5p), n3p/(1-l3p), use='complete.obs')])
), digits=3)
```

```{r plot_corr_flanks, fig.height=6, fig.width=8}
p <- function(n.obs.5p, n.obs.3p, labels, type, first=FALSE, main) {
  missing <- !is.finite(n.obs.5p) | (n.obs.5p == 0) | !is.finite(n.obs.3p) | (n.obs.3p == 0)
  plot_ly(showlegend=first) %>%
  add_markers(x=n.obs.5p[!missing],
              y=n.obs.3p[!missing],
              color=I("black"),
              text=labels[!missing], name="UMIs found for 5' and 3' flank", legendgroup="nz",
              marker=list(symbol="circle-open")) %>%
  add_markers(x=pmax(n.obs.5p[missing], 1, na.rm=TRUE),
              y=pmax(n.obs.3p[missing], 1, na.rm=TRUE),
              color=I("black"),
              text=labels[missing], name="No UMIs found for 5' or 3' flank", legendgroup="z",
              marker=list(symbol="x")) %>%
  layout(xaxis=list(type="log", title=paste0(type, " #UMIs 5'")),
         yaxis=list(type="log", title=paste0(type, " #UMIs 3'")),
         annotations=list(x=0.5, y=1, text = main, xanchor="center", yanchor="bottom",
                          xref='paper', yref='paper',
                          showarrow=F, font=list(size=15)))
}

p.raw.in <- group.by.knockout(counts.flank.in)[, {
  p(n5p, n3p, knockout, main="Input 5' vs. 3' flank (raw)", type="Raw", first=TRUE)
}]
p.raw.out <- group.by.knockout(counts.flank.out)[, {
  p(n5p, n3p, knockout, main="Output 5' vs. 3' flank (raw)", type="Raw")
}]
p.corr.in <- d <- group.by.knockout(counts.flank.in)[, {
  p(n5p/(1-l5p), n3p/(1-l3p), knockout, main="Input 5' vs. 3' flank (loss-corrected)", type="Loss-corr.")
}]
p.corr.out <- d <- group.by.knockout(counts.flank.out)[, {
  p(n5p/(1-l5p), n3p/(1-l3p), knockout, main="Output 5' vs. 3' flank (loss-corrected)", type="Loss-corr.")
}]
subplot(list(p.raw.in, p.raw.out, p.corr.in, p.corr.out), nrows=2,
        titleX=TRUE, titleY=TRUE, margin=0.12) %>%
layout(width=1000, height=600)
```

## Correlation of Input and Output

```{r table_corr_io}
group.by.knockout <- function(data) {
  data[, list(n5p=n.obs[flank=="5p"],
              l5p=loss[flank=="5p"],
              n3p=n.obs[flank=="3p"],
              l3p=loss[flank=="3p"])
       , by="knockout"]
}

knitr::kable(data.table(
  Type=c(
  "Raw",
  "Loss-corr."
  ),
  `Correlation Input vs. Output`=c(
  counts[, cor(n.in, n.out, use='complete.obs')],
  counts[, cor(abundance.in, abundance.out, use='complete.obs')])
), digits=3)
```

```{r plot_corr_io, fig.height=3, fig.width=8}
p <- function(abd.in, abd.out, labels, type, first=FALSE, main) {
  missing <- !is.finite(abd.in) | (abd.in == 0) | !is.finite(abd.out) | (abd.out == 0)
  plot_ly(showlegend=first) %>%
  add_markers(x=abd.in[!missing],
              y=abd.out[!missing],
              color=I("black"),
              text=labels[!missing], name="present in input and output", legendgroup="nz",
              marker=list(symbol="circle-open")) %>%
  add_markers(x=pmax(abd.in[missing], 1, na.rm=TRUE),
              y=pmax(abd.out[missing], 1, na.rm=TRUE),
              color=I("black"),
              text=labels[missing], name="missing in input or output", legendgroup="z",
              marker=list(symbol="x")) %>%
  layout(xaxis=list(type="log", title=paste0(type, " #UMIs in input")),
         yaxis=list(type="log", title=paste0(type, " #UMIs in output")),
         annotations=list(x=0.5, y=1, text = main, xanchor="center", yanchor="bottom",
                          xref='paper', yref='paper',
                          showarrow=F, font=list(size=15)))
}

p.raw <- counts[, {
  p(n.in, n.out, knockout, main="Input vs. Output (raw)", type="Raw", first=TRUE)
}]
p.corr <- counts[, {
  p(abundance.in, abundance.out, knockout, main="Input vs. Output (loss-corr.)", type="Loss-corr.")
}]
subplot(list(p.raw, p.corr), nrows=1,
        titleX=TRUE, titleY=TRUE, margin=0.12) %>%
layout(width=1000, height=300)
```

## Model Parameter & Fit

```{r fit_model}
# Fit null model
null.model <- counts[is.neutral & (n.in > 0) & (n.out > 0), {
  ipsmodel.fit(n.out=n.out, n.in=n.in, l.out=loss.out, l.in=loss.in)
}]
knitr::kable(signif(null.model, digits=3),
             col.names=c('Scale (lambda)', 'Dispersion (d)'))
```

# 3. Results

## Log2 fold changes relative to neutral knockouts

```{r sig_test}
# Compute log2 fold changes and p-values
results <- counts[, list(
  knockout, is.neutral,
  n.out, loss.out, abundance.out,
  n.in, loss.in, abundance.in,
  log2fc=ifelse(is.finite(abundance.out) & is.finite(abundance.in) & (abundance.in>0) & (abundance.out>0),
                log2(abundance.out / (null.model$scale * abundance.in)),
                NA_real_),
  low.pval=ifelse(is.finite(n.out) & is.finite(n.in) & (n.out > 0) & (n.in > 0),
                  pipsmodel(n.out, null.model$scale, null.model$disp, n.in, loss.out, loss.in),
                  NA_real_),
  high.pval=ifelse(is.finite(n.out) & is.finite(n.in) & (n.out > 0) & (n.in > 0),
                  1 - pipsmodel(n.out - 1, null.model$scale, null.model$disp, n.in, loss.out, loss.in),
                  NA_real_)
)]

# Compute q-values using the method of Benjamini & Hochberg (BH)
results[, low.qval := p.adjust(low.pval, method='BH')]
results[, high.qval := p.adjust(high.pval, method='BH')]

# Write output table
write.table(results, file=snakemake@output$table, col.names=TRUE, sep="\t", row.names=FALSE)
```

```{r plot_log2fc}
# Compute (approximate) insigificance region
loss.out <- mean(results$loss.out, na.rm=TRUE)
loss.in <- mean(results$loss.in, na.rm=TRUE)
a.in <- 10**seq(from=0, to=2*log10(max(results$abundance.in, na.rm=TRUE)), length.out=200)
l2fc.low <- log2(pmax(qipsmodel(p=rep(PLOT.FDR.THRESHOLD, along.with=a.in),
                                scale=null.model$scale, disp=null.model$disp,
                                n.in=a.in * (1 - loss.in), l.out=loss.out, l.in=loss.in) - 1, 0) /
                 ((1 - loss.out) * a.in * null.model$scale))
l2fc.high <- log2(pmax(qipsmodel(p=rep(1 - PLOT.FDR.THRESHOLD, along.with=a.in),
                                 scale=null.model$scale, disp=null.model$disp,
                                 n.in=a.in * (1 - loss.in), l.out=loss.out, l.in=loss.in) + 1, 0) /
                 ((1 - loss.out) * a.in * null.model$scale))

plot_ly() %>%
add_trace(x=c(a.in, rev(a.in)),
          y=pmax(c(rev(cummin(rev(l2fc.low))),
                   cummax(rev(l2fc.high))),
                 10*min(results$log2fc, 0, na.rm=TRUE)),
          name='insignificant area (approximate, without FDR correction)',
          type='scatter', mode='none', fill='toself', fillcolor='lightgrey') %>%
add_trace(x=results[!is.neutral & (low.qval >= PLOT.FDR.THRESHOLD) & (high.qval >= PLOT.FDR.THRESHOLD), abundance.in],
          y=results[!is.neutral & (low.qval >= PLOT.FDR.THRESHOLD) & (high.qval >= PLOT.FDR.THRESHOLD), log2fc],
          text=results[!is.neutral & (low.qval >= PLOT.FDR.THRESHOLD) & (high.qval >= PLOT.FDR.THRESHOLD), knockout],
          name='insignificant change of virulence',
          marker=list(symbol="circle-open", color='darkgrey'),
          type="scatter", mode="markers") %>%
add_trace(x=results[is.neutral==TRUE, abundance.in],
          y=results[is.neutral==TRUE, log2fc],
          text=results[is.neutral==TRUE, knockout],
          name='neutral reference set',
          marker=list(symbol="circle-open", color='darkgreen'),
          type="scatter", mode="markers") %>%
add_trace(x=results[low.qval <= PLOT.FDR.THRESHOLD, abundance.in],
          y=results[low.qval <= PLOT.FDR.THRESHOLD, log2fc],
          text=results[low.qval <= PLOT.FDR.THRESHOLD, knockout],
          name='significantly reduced virulence',
          marker=list(symbol="circle-open", color='red'),
          type="scatter", mode="markers") %>%
add_trace(x=results[high.qval <= PLOT.FDR.THRESHOLD, abundance.in],
          y=results[high.qval <= PLOT.FDR.THRESHOLD, log2fc],
          text=results[high.qval <= PLOT.FDR.THRESHOLD, knockout],
          name='significantly increased virulence',
          marker=list(symbol="circle-open", color='blue'),
          type="scatter", mode="markers") %>%
layout(xaxis=list(range=c(0, ceiling(max(log10(results$abundance.in), na.rm=TRUE))), type="log",
                  title="input abundance (loss-corr. #UMIs)"),
       yaxis=list(range=c(floor(min(results$log2fc, na.rm=TRUE)),
                          ceiling(max(results$log2fc, na.rm=TRUE))),
                  title=paste0("log2 virulence fold change")))
```

## Depletion of knockouts in the output compared to neutral knockout

```{r table_depleted}
DT::datatable(results[!is.na(log2fc), list(
  knockout, is.neutral, log2fc, pval=low.pval, qval=low.qval, sig=sig.stars(low.qval)
)], filter="top") %>%
  formatRound(columns=c("log2fc"), digits=2) %>%
  formatSignif(columns=c("pval", "qval"), digits=2)
```

## Enrichment of knockouts in the output compared to neutral knockout

```{r table_enriched}
DT::datatable(results[!is.na(log2fc), list(
  knockout, is.neutral, log2fc, pval=high.pval, qval=high.qval, sig=sig.stars(high.qval)
)], filter="top") %>%
  formatRound(columns=c("log2fc"), digits=2) %>%
  formatSignif(columns=c("pval", "qval"), digits=2)
```

